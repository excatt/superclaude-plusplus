#!/bin/bash
# Generated by cc-statusline v1.3.1 (https://www.npmjs.com/package/@chongdashu/cc-statusline)
# Custom Claude Code statusline - Created: 2025-08-28T15:49:40.729Z
# Theme: detailed | Colors: true | Features: directory, git, model, context, usage, session, tokens, burnrate
STATUSLINE_VERSION="1.3.1"

input=$(cat)

# Get the directory where this statusline script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="${SCRIPT_DIR}/statusline.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# ---- check jq availability ----
HAS_JQ=0
if command -v jq >/dev/null 2>&1; then
  HAS_JQ=1
fi

# ---- logging ----
{
  echo "[$TIMESTAMP] Status line triggered (cc-statusline v${STATUSLINE_VERSION})"
  echo "[$TIMESTAMP] Input:"
  if [ "$HAS_JQ" -eq 1 ]; then
    echo "$input" | jq . 2>/dev/null || echo "$input"
    echo "[$TIMESTAMP] Using jq for JSON parsing"
  else
    echo "$input"
    echo "[$TIMESTAMP] WARNING: jq not found, using bash fallback for JSON parsing"
  fi
  echo "---"
} >> "$LOG_FILE" 2>/dev/null

# ---- color helpers (force colors for Claude Code) ----
use_color=1
[ -n "$NO_COLOR" ] && use_color=0

C() { if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$1"; fi; }
RST() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- modern sleek colors ----
dir_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;117m'; fi; }    # sky blue
model_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;147m'; fi; }  # light purple  
version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;180m'; fi; } # soft yellow
cc_version_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;249m'; fi; } # light gray
style_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;245m'; fi; } # gray
lines_add_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;114m'; fi; } # green for additions
lines_del_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;210m'; fi; } # red for deletions
warning_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;196m'; fi; } # bright red for warning
vim_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;81m'; fi; }     # bright cyan for vim
agent_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;213m'; fi; }  # pink for agent
api_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;183m'; fi; }    # light violet for API
cache_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;116m'; fi; }  # teal for cache
link_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;243m'; fi; }   # dim gray for transcript
model_id_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;103m'; fi; } # muted purple for model id
rst() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- time helpers ----
to_epoch() {
  ts="$1"
  if command -v gdate >/dev/null 2>&1; then gdate -d "$ts" +%s 2>/dev/null && return; fi
  date -u -j -f "%Y-%m-%dT%H:%M:%S%z" "${ts/Z/+0000}" +%s 2>/dev/null && return
  python3 - "$ts" <<'PY' 2>/dev/null
import sys, datetime
s=sys.argv[1].replace('Z','+00:00')
print(int(datetime.datetime.fromisoformat(s).timestamp()))
PY
}

fmt_time_hm() {
  epoch="$1"
  if date -r 0 +%s >/dev/null 2>&1; then date -r "$epoch" +"%H:%M"; else date -d "@$epoch" +"%H:%M"; fi
}

progress_bar() {
  pct="${1:-0}"; width="${2:-10}"
  [[ "$pct" =~ ^[0-9]+$ ]] || pct=0; ((pct<0))&&pct=0; ((pct>100))&&pct=100
  filled=$(( pct * width / 100 )); empty=$(( width - filled ))
  printf '%*s' "$filled" '' | tr ' ' '='
  printf '%*s' "$empty" '' | tr ' ' '-'
}

# git utilities
num_or_zero() { v="$1"; [[ "$v" =~ ^[0-9]+$ ]] && echo "$v" || echo 0; }

# ---- JSON extraction utilities ----
# Pure bash JSON value extractor (fallback when jq not available)
extract_json_string() {
  local json="$1"
  local key="$2"
  local default="${3:-}"
  
  # For nested keys like workspace.current_dir, get the last part
  local field="${key##*.}"
  field="${field%% *}"  # Remove any jq operators
  
  # Try to extract string value (quoted)
  local value=$(echo "$json" | grep -o "\"\${field}\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | head -1 | sed 's/.*:[[:space:]]*"\([^"]*\)".*/\1/')
  
  # Convert escaped backslashes to forward slashes for Windows paths
  if [ -n "$value" ]; then
    value=$(echo "$value" | sed 's/\\\\/\//g')
  fi
  
  # If no string value found, try to extract number value (unquoted)
  if [ -z "$value" ] || [ "$value" = "null" ]; then
    value=$(echo "$json" | grep -o "\"\${field}\"[[:space:]]*:[[:space:]]*[0-9.]\+" | head -1 | sed 's/.*:[[:space:]]*\([0-9.]\+\).*/\1/')
  fi
  
  # Return value or default
  if [ -n "$value" ] && [ "$value" != "null" ]; then
    echo "$value"
  else
    echo "$default"
  fi
}

# ---- basics ----
if [ "$HAS_JQ" -eq 1 ]; then
  current_dir=$(echo "$input" | jq -r '.workspace.current_dir // .cwd // "unknown"' 2>/dev/null | sed "s|^$HOME|~|g")
  model_name=$(echo "$input" | jq -r '.model.display_name // "Claude"' 2>/dev/null)
  model_version=$(echo "$input" | jq -r '.model.version // ""' 2>/dev/null)
  session_id=$(echo "$input" | jq -r '.session_id // ""' 2>/dev/null)
  cc_version=$(echo "$input" | jq -r '.version // ""' 2>/dev/null)
  output_style=$(echo "$input" | jq -r '.output_style.name // ""' 2>/dev/null)
  lines_added=$(echo "$input" | jq -r '.cost.total_lines_added // 0' 2>/dev/null)
  lines_removed=$(echo "$input" | jq -r '.cost.total_lines_removed // 0' 2>/dev/null)
  exceeds_200k=$(echo "$input" | jq -r '.exceeds_200k_tokens // false' 2>/dev/null)
  model_id=$(echo "$input" | jq -r '.model.id // ""' 2>/dev/null)
  vim_mode=$(echo "$input" | jq -r '.vim.mode // ""' 2>/dev/null)
  agent_name=$(echo "$input" | jq -r '.agent.name // ""' 2>/dev/null)
  transcript_path=$(echo "$input" | jq -r '.transcript_path // ""' 2>/dev/null)
  api_duration_ms=$(echo "$input" | jq -r '.cost.total_api_duration_ms // ""' 2>/dev/null)
  ctx_used_pct=$(echo "$input" | jq -r '.context_window.used_percentage // ""' 2>/dev/null)
  ctx_remaining_pct=$(echo "$input" | jq -r '.context_window.remaining_percentage // ""' 2>/dev/null)
  ctx_window_size=$(echo "$input" | jq -r '.context_window.context_window_size // ""' 2>/dev/null)
  ctx_input_tokens=$(echo "$input" | jq -r '.context_window.current_usage.input_tokens // ""' 2>/dev/null)
  ctx_output_tokens=$(echo "$input" | jq -r '.context_window.current_usage.output_tokens // ""' 2>/dev/null)
  ctx_cache_creation=$(echo "$input" | jq -r '.context_window.current_usage.cache_creation_input_tokens // ""' 2>/dev/null)
  ctx_cache_read=$(echo "$input" | jq -r '.context_window.current_usage.cache_read_input_tokens // ""' 2>/dev/null)
else
  # Bash fallback for JSON extraction
  # Extract current_dir from workspace object - look for the pattern workspace":{"current_dir":"..."}
  current_dir=$(echo "$input" | grep -o '"workspace"[[:space:]]*:[[:space:]]*{[^}]*"current_dir"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"current_dir"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | sed 's/\\\\/\//g')
  
  # Fall back to cwd if workspace extraction failed
  if [ -z "$current_dir" ] || [ "$current_dir" = "null" ]; then
    current_dir=$(echo "$input" | grep -o '"cwd"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"cwd"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' | sed 's/\\\\/\//g')
  fi
  
  # Fallback to unknown if all extraction failed
  [ -z "$current_dir" ] && current_dir="unknown"
  current_dir=$(echo "$current_dir" | sed "s|^$HOME|~|g")
  
  # Extract model name from nested model object
  model_name=$(echo "$input" | grep -o '"model"[[:space:]]*:[[:space:]]*{[^}]*"display_name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"display_name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  [ -z "$model_name" ] && model_name="Claude"
  # Model version is in the model ID, not a separate field  
  model_version=""  # Not available in Claude Code JSON
  session_id=$(extract_json_string "$input" "session_id" "")
  # CC version is at the root level
  cc_version=$(echo "$input" | grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  # Output style is nested
  output_style=$(echo "$input" | grep -o '"output_style"[[:space:]]*:[[:space:]]*{[^}]*"name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/')
  # Lines changed
  lines_added=$(echo "$input" | grep -o '"total_lines_added"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*\([0-9]*\).*/\1/')
  lines_removed=$(echo "$input" | grep -o '"total_lines_removed"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*\([0-9]*\).*/\1/')
  [ -z "$lines_added" ] && lines_added=0
  [ -z "$lines_removed" ] && lines_removed=0
  # 200K warning
  exceeds_200k=$(echo "$input" | grep -o '"exceeds_200k_tokens"[[:space:]]*:[[:space:]]*[a-z]*' | sed 's/.*:[[:space:]]*\([a-z]*\).*/\1/')
  [ -z "$exceeds_200k" ] && exceeds_200k="false"
  model_id=""
  vim_mode=""
  agent_name=""
  transcript_path=""
  api_duration_ms=""
  ctx_used_pct=""
  ctx_remaining_pct=""
  ctx_window_size=""
  ctx_input_tokens=""
  ctx_output_tokens=""
  ctx_cache_creation=""
  ctx_cache_read=""
fi

# ---- git colors ----
git_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;150m'; fi; }  # soft green
rst() { if [ "$use_color" -eq 1 ]; then printf '\033[0m'; fi; }

# ---- git ----
git_branch=""
if git rev-parse --git-dir >/dev/null 2>&1; then
  git_branch=$(git branch --show-current 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
fi

# ---- context window calculation ----
context_pct=""
context_remaining_pct=""
context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[1;37m'; fi; }  # default white

# Determine max context based on model
get_max_context() {
  local model_name="$1"
  case "$model_name" in
    *"Opus 4"*|*"opus 4"*|*"Opus"*|*"opus"*)
      echo "200000"  # 200K for all Opus versions
      ;;
    *"Sonnet 4"*|*"sonnet 4"*|*"Sonnet 3.5"*|*"sonnet 3.5"*|*"Sonnet"*|*"sonnet"*)
      echo "200000"  # 200K for Sonnet 3.5+ and 4.x
      ;;
    *"Haiku 3.5"*|*"haiku 3.5"*|*"Haiku 4"*|*"haiku 4"*|*"Haiku"*|*"haiku"*)
      echo "200000"  # 200K for modern Haiku
      ;;
    *"Claude 3 Haiku"*|*"claude 3 haiku"*)
      echo "100000"  # 100K for original Claude 3 Haiku
      ;;
    *)
      echo "200000"  # Default to 200K
      ;;
  esac
}

fmt_tokens() {
  local t="$1"
  if [ "$t" -ge 1000000 ] 2>/dev/null; then
    printf '%.1fM' "$(echo "$t" | awk '{printf "%.1f", $1/1000000}')"
  elif [ "$t" -ge 1000 ] 2>/dev/null; then
    echo "$(( t / 1000 ))K"
  else
    echo "$t"
  fi
}

# Prefer API-provided context_window data, fall back to session file parsing
if [ -n "$ctx_used_pct" ] && [ "$ctx_used_pct" != "null" ] && [ "$ctx_used_pct" != "" ]; then
  # --- Use API direct data ---
  ctx_used_int=$(printf '%.0f' "$ctx_used_pct" 2>/dev/null || echo 0)
  ctx_rem_int=$(printf '%.0f' "$ctx_remaining_pct" 2>/dev/null || echo 100)
  context_remaining_pct="$ctx_rem_int"

  MAX_CONTEXT="${ctx_window_size:-200000}"
  max_context_fmt=$(fmt_tokens "$MAX_CONTEXT")

  # Calculate used tokens from percentage
  latest_tokens=$(echo "$ctx_used_int $MAX_CONTEXT" | awk '{printf "%.0f", $1 * $2 / 100}')
  latest_tokens_fmt=$(fmt_tokens "$latest_tokens")

  # Set color based on remaining percentage
  if [ "$ctx_rem_int" -le 20 ]; then
    context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;203m'; fi; }  # coral red
  elif [ "$ctx_rem_int" -le 40 ]; then
    context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;215m'; fi; }  # peach
  else
    context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;158m'; fi; }  # mint green
  fi

  context_pct="${ctx_rem_int}%"
  context_detail="${latest_tokens_fmt}/${max_context_fmt}"

elif [ -n "$session_id" ] && [ "$HAS_JQ" -eq 1 ]; then
  # --- Fallback: parse session file ---
  MAX_CONTEXT=$(get_max_context "$model_name")

  project_dir=$(echo "$current_dir" | sed "s|~|$HOME|g" | sed 's|/|-|g' | sed 's|^-||')
  session_file="$HOME/.claude/projects/-${project_dir}/${session_id}.jsonl"

  if [ -f "$session_file" ]; then
    latest_tokens=$(tail -20 "$session_file" | jq -r 'select(.message.usage) | .message.usage | ((.input_tokens // 0) + (.cache_creation_input_tokens // 0) + (.cache_read_input_tokens // 0))' 2>/dev/null | tail -1)

    if [ -n "$latest_tokens" ] && [ "$latest_tokens" -gt 0 ]; then
      context_used_pct=$(( latest_tokens * 100 / MAX_CONTEXT ))
      context_remaining_pct=$(( 100 - context_used_pct ))

      latest_tokens_fmt=$(fmt_tokens "$latest_tokens")
      max_context_fmt=$(fmt_tokens "$MAX_CONTEXT")

      if [ "$context_remaining_pct" -le 20 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;203m'; fi; }  # coral red
      elif [ "$context_remaining_pct" -le 40 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;215m'; fi; }  # peach
      else
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;158m'; fi; }  # mint green
      fi

      context_pct="${context_remaining_pct}%"
      context_detail="${latest_tokens_fmt}/${max_context_fmt}"
    fi
  fi
fi

# ---- usage colors ----
usage_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;189m'; fi; }  # lavender
cost_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;222m'; fi; }   # light gold
burn_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;220m'; fi; }   # bright gold
session_color() { 
  rem_pct=$(( 100 - session_pct ))
  if   (( rem_pct <= 10 )); then SCLR='38;5;210'  # light pink
  elif (( rem_pct <= 25 )); then SCLR='38;5;228'  # light yellow  
  else                          SCLR='38;5;194'; fi  # light green
  if [ "$use_color" -eq 1 ]; then printf '\033[%sm' "$SCLR"; fi
}

# ---- cost and usage extraction ----
session_txt=""; session_pct=0; session_bar=""
cost_usd=""; cost_per_hour=""; tpm=""; tot_tokens=""

# ---- TODO tracking ----
todo_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;156m'; fi; }  # light green
todo_warning_color() { if [ "$use_color" -eq 1 ]; then printf '\033[38;5;214m'; fi; }  # orange
todo_complete=0
todo_pending=0
todo_inprogress=0
todo_total=0

# Check Claude's internal todo system
TODOS_DIR="$HOME/.claude/todos"
if [ -d "$TODOS_DIR" ] && [ "$HAS_JQ" -eq 1 ]; then
  for todo_file in "$TODOS_DIR"/*.json; do
    if [ -f "$todo_file" ]; then
      completed=$(jq '[.[] | select(.status == "completed")] | length' "$todo_file" 2>/dev/null || echo "0")
      pending=$(jq '[.[] | select(.status == "pending")] | length' "$todo_file" 2>/dev/null || echo "0")
      inprogress=$(jq '[.[] | select(.status == "in_progress")] | length' "$todo_file" 2>/dev/null || echo "0")
      todo_complete=$((todo_complete + completed))
      todo_pending=$((todo_pending + pending))
      todo_inprogress=$((todo_inprogress + inprogress))
    fi
  done
  todo_total=$((todo_complete + todo_pending + todo_inprogress))
fi

# Extract cost data from Claude Code input
if [ "$HAS_JQ" -eq 1 ]; then
  # Get cost data from Claude Code's input
  cost_usd=$(echo "$input" | jq -r '.cost.total_cost_usd // empty' 2>/dev/null)
  total_duration_ms=$(echo "$input" | jq -r '.cost.total_duration_ms // empty' 2>/dev/null)
  
  # Calculate burn rate ($/hour) from cost and duration
  if [ -n "$cost_usd" ] && [ -n "$total_duration_ms" ] && [ "$total_duration_ms" -gt 0 ]; then
    # Convert ms to hours and calculate rate
    cost_per_hour=$(echo "$cost_usd $total_duration_ms" | awk '{printf "%.2f", $1 * 3600000 / $2}')
  fi
else
  # Bash fallback for cost extraction
  cost_usd=$(echo "$input" | grep -o '"total_cost_usd"[[:space:]]*:[[:space:]]*[0-9.]*' | sed 's/.*:[[:space:]]*\([0-9.]*\).*/\1/')
  total_duration_ms=$(echo "$input" | grep -o '"total_duration_ms"[[:space:]]*:[[:space:]]*[0-9]*' | sed 's/.*:[[:space:]]*\([0-9]*\).*/\1/')  
  
  # Calculate burn rate ($/hour) from cost and duration
  if [ -n "$cost_usd" ] && [ -n "$total_duration_ms" ] && [ "$total_duration_ms" -gt 0 ]; then
    # Convert ms to hours and calculate rate
    cost_per_hour=$(echo "$cost_usd $total_duration_ms" | awk '{printf "%.2f", $1 * 3600000 / $2}')
  fi
fi

# Get token data and session info from ccusage if available
if command -v ccusage >/dev/null 2>&1 && [ "$HAS_JQ" -eq 1 ]; then
  blocks_output=""
  
  # Try ccusage with timeout for token data and session info
  if command -v timeout >/dev/null 2>&1; then
    blocks_output=$(timeout 5s ccusage blocks --json 2>/dev/null)
  elif command -v gtimeout >/dev/null 2>&1; then
    # macOS with coreutils installed
    blocks_output=$(gtimeout 5s ccusage blocks --json 2>/dev/null)
  else
    # No timeout available, run directly (ccusage should be fast)
    blocks_output=$(ccusage blocks --json 2>/dev/null)
  fi
  if [ -n "$blocks_output" ]; then
    active_block=$(echo "$blocks_output" | jq -c '.blocks[] | select(.isActive == true)' 2>/dev/null | head -n1)
    if [ -n "$active_block" ]; then
      # Get token count from ccusage
      tot_tokens=$(echo "$active_block" | jq -r '.totalTokens // empty')
      # Get tokens per minute from ccusage
      tpm=$(echo "$active_block" | jq -r '.burnRate.tokensPerMinute // empty')
      
      # Session time calculation from ccusage
      reset_time_str=$(echo "$active_block" | jq -r '.usageLimitResetTime // .endTime // empty')
      start_time_str=$(echo "$active_block" | jq -r '.startTime // empty')
      
      if [ -n "$reset_time_str" ] && [ -n "$start_time_str" ]; then
        start_sec=$(to_epoch "$start_time_str"); end_sec=$(to_epoch "$reset_time_str"); now_sec=$(date +%s)
        total=$(( end_sec - start_sec )); (( total<1 )) && total=1
        elapsed=$(( now_sec - start_sec )); (( elapsed<0 ))&&elapsed=0; (( elapsed>total ))&&elapsed=$total
        session_pct=$(( elapsed * 100 / total ))
        remaining=$(( end_sec - now_sec )); (( remaining<0 )) && remaining=0
        rh=$(( remaining / 3600 )); rm=$(( (remaining % 3600) / 60 ))
        end_hm=$(fmt_time_hm "$end_sec")
        session_txt="$(printf '%dh %dm until reset at %s (%d%%)' "$rh" "$rm" "$end_hm" "$session_pct")"
        session_bar=$(progress_bar "$session_pct" 10)
      fi
    fi
  fi
fi

# ---- log extracted data ----
{
  echo "[$TIMESTAMP] Extracted: dir=${current_dir:-}, model=${model_name:-}(${model_id:-}), version=${model_version:-}, git=${git_branch:-}, context=${context_pct:-}, cost=${cost_usd:-}, cost_ph=${cost_per_hour:-}, tokens=${tot_tokens:-}, tpm=${tpm:-}, session_pct=${session_pct:-}, vim=${vim_mode:-}, agent=${agent_name:-}, api_ms=${api_duration_ms:-}, ctx_in=${ctx_input_tokens:-}, ctx_out=${ctx_output_tokens:-}, cache_r=${ctx_cache_read:-}, cache_c=${ctx_cache_creation:-}"
  if [ "$HAS_JQ" -eq 0 ]; then
    echo "[$TIMESTAMP] Note: Context, tokens, and session info require jq for full functionality"
  fi
} >> "$LOG_FILE" 2>/dev/null

# ---- language version detection ----
lang_version=""
lang_icon=""

# Get actual directory path (resolve ~)
real_dir=$(echo "$current_dir" | sed "s|~|$HOME|g")

# Check for Node.js project
if [ -f "${real_dir}/package.json" ]; then
  if command -v node >/dev/null 2>&1; then
    node_version=$(node --version 2>/dev/null | sed 's/v//')
    if [ -n "$node_version" ]; then
      lang_version="$node_version"
      lang_icon="‚¨¢"  # Node.js hexagon
    fi
  fi
# Check for Python project
elif [ -f "${real_dir}/pyproject.toml" ] || [ -f "${real_dir}/requirements.txt" ]; then
  if command -v python3 >/dev/null 2>&1; then
    python_version=$(python3 --version 2>/dev/null | awk '{print $2}')
    if [ -n "$python_version" ]; then
      lang_version="$python_version"
      lang_icon="üêç"  # Python snake
    fi
  elif command -v python >/dev/null 2>&1; then
    python_version=$(python --version 2>/dev/null | awk '{print $2}')
    if [ -n "$python_version" ]; then
      lang_version="$python_version"
      lang_icon="üêç"  # Python snake
    fi
  fi
fi

# ---- render statusline ----
# Line 1: Core info (directory, git, model, claude code version, output style)
printf 'üìÅ %s%s%s' "$(dir_color)" "$current_dir" "$(rst)"
if [ -n "$git_branch" ]; then
  printf '  üåø %s%s%s' "$(git_color)" "$git_branch" "$(rst)"
fi
# Add language version after git branch
if [ -n "$lang_version" ]; then
  printf '  %s %s%s%s' "$lang_icon" "$(version_color)" "$lang_version" "$(rst)"
fi
printf '  ü§ñ %s%s%s' "$(model_color)" "$model_name" "$(rst)"
if [ -n "$model_version" ] && [ "$model_version" != "null" ]; then
  printf '  üè∑Ô∏è %s%s%s' "$(version_color)" "$model_version" "$(rst)"
fi
if [ -n "$cc_version" ] && [ "$cc_version" != "null" ]; then
  printf '  üìü %sv%s%s' "$(cc_version_color)" "$cc_version" "$(rst)"
fi
if [ -n "$output_style" ] && [ "$output_style" != "null" ]; then
  printf '  üé® %s%s%s' "$(style_color)" "$output_style" "$(rst)"
fi
# Vim mode
if [ -n "$vim_mode" ] && [ "$vim_mode" != "null" ]; then
  if [ "$vim_mode" = "NORMAL" ]; then
    printf '  %s[N]%s' "$(vim_color)" "$(rst)"
  elif [ "$vim_mode" = "INSERT" ]; then
    printf '  %s[I]%s' "$(vim_color)" "$(rst)"
  else
    printf '  %s[%s]%s' "$(vim_color)" "$vim_mode" "$(rst)"
  fi
fi
# Agent name
if [ -n "$agent_name" ] && [ "$agent_name" != "null" ]; then
  printf '  üïµÔ∏è %s%s%s' "$(agent_color)" "$agent_name" "$(rst)"
fi
# Lines changed (additions/deletions)
if [ -n "$lines_added" ] || [ -n "$lines_removed" ]; then
  printf '  üìù %s+%s%s/%s-%s%s' "$(lines_add_color)" "${lines_added:-0}" "$(rst)" "$(lines_del_color)" "${lines_removed:-0}" "$(rst)"
fi

# Line 2: Context, session ID, and session time
line2=""
if [ -n "$context_pct" ]; then
  context_bar=$(progress_bar "$context_remaining_pct" 10)
  # Context temperature indicator
  if [ "$context_remaining_pct" -le 20 ]; then
    temp_emoji="üî¥"
  elif [ "$context_remaining_pct" -le 40 ]; then
    temp_emoji="üü°"
  else
    temp_emoji="üü¢"
  fi
  if [ -n "$context_detail" ]; then
    line2="${temp_emoji} üß† $(context_color)Context: ${context_detail} (${context_pct} remaining) [${context_bar}]$(rst)"
  else
    line2="${temp_emoji} üß† $(context_color)Context Remaining: ${context_pct} [${context_bar}]$(rst)"
  fi
fi
# Add current usage breakdown (input/output/cache)
if [ -n "$ctx_input_tokens" ] && [ "$ctx_input_tokens" != "null" ] && [ "$ctx_input_tokens" != "" ] && [ "$ctx_input_tokens" != "0" ]; then
  in_fmt=$(fmt_tokens "$ctx_input_tokens")
  out_fmt=$(fmt_tokens "${ctx_output_tokens:-0}")
  cache_info=""
  if [ -n "$ctx_cache_read" ] && [ "$ctx_cache_read" != "null" ] && [ "$ctx_cache_read" != "" ] && [ "$ctx_cache_read" != "0" ]; then
    cr_fmt=$(fmt_tokens "$ctx_cache_read")
    cache_info=" $(cache_color)cache:${cr_fmt}$(rst)"
  fi
  if [ -n "$ctx_cache_creation" ] && [ "$ctx_cache_creation" != "null" ] && [ "$ctx_cache_creation" != "" ] && [ "$ctx_cache_creation" != "0" ]; then
    cc_fmt=$(fmt_tokens "$ctx_cache_creation")
    cache_info="${cache_info} $(cache_color)+${cc_fmt}$(rst)"
  fi
  usage_detail="$(usage_color)in:${in_fmt} out:${out_fmt}$(rst)${cache_info}"
  if [ -n "$line2" ]; then
    line2="$line2  üì¶ $usage_detail"
  else
    line2="üì¶ $usage_detail"
  fi
fi
# Add session ID next to context
if [ -n "$session_id" ] && [ "$session_id" != "null" ]; then
  short_session_id="${session_id:0:8}"
  if [ -n "$line2" ]; then
    line2="$line2  üîë $(cc_version_color)${short_session_id}$(rst)"
  else
    line2="üîë $(cc_version_color)${short_session_id}$(rst)"
  fi
fi
# 200K token warning
if [ "$exceeds_200k" = "true" ]; then
  if [ -n "$line2" ]; then
    line2="$line2  üö® $(warning_color)EXCEEDS 200K TOKENS$(rst)"
  else
    line2="üö® $(warning_color)EXCEEDS 200K TOKENS$(rst)"
  fi
fi
if [ -n "$session_txt" ]; then
  if [ -n "$line2" ]; then
    line2="$line2  ‚åõ $(session_color)${session_txt}$(rst) $(session_color)[${session_bar}]$(rst)"
  else
    line2="‚åõ $(session_color)${session_txt}$(rst) $(session_color)[${session_bar}]$(rst)"
  fi
fi
if [ -z "$line2" ] && [ -z "$context_pct" ]; then
  line2="üß† $(context_color)Context Remaining: TBD$(rst)"
fi

# Line 3: Token usage, cost, and TODO tracking
line3=""
if [ -n "$tot_tokens" ] && [[ "$tot_tokens" =~ ^[0-9]+$ ]]; then
  if [ -n "$tpm" ] && [[ "$tpm" =~ ^[0-9.]+$ ]]; then
    tpm_formatted=$(printf '%.0f' "$tpm")
    line3="üìä $(usage_color)${tot_tokens} tok (${tpm_formatted} tpm)$(rst)"
  else
    line3="üìä $(usage_color)${tot_tokens} tok$(rst)"
  fi
fi

# Add cost info
if [ -n "$cost_usd" ] && [ "$cost_usd" != "0" ] && [ "$cost_usd" != "null" ]; then
  cost_formatted=$(printf '$%.2f' "$cost_usd")
  cost_info="üí∞ $(cost_color)${cost_formatted}$(rst)"
  if [ -n "$cost_per_hour" ] && [ "$cost_per_hour" != "0.00" ]; then
    cost_info="$cost_info $(burn_color)(\$${cost_per_hour}/hr)$(rst)"
  fi
  if [ -n "$total_duration_ms" ] && [ "$total_duration_ms" -gt 0 ] 2>/dev/null; then
    total_sec=$((total_duration_ms / 1000))
    dur_min=$((total_sec / 60))
    dur_sec=$((total_sec % 60))
    if [ "$dur_min" -gt 0 ]; then
      cost_info="$cost_info  ‚è±Ô∏è $(usage_color)${dur_min}m ${dur_sec}s$(rst)"
    else
      cost_info="$cost_info  ‚è±Ô∏è $(usage_color)${dur_sec}s$(rst)"
    fi
  fi
  if [ -n "$line3" ]; then
    line3="$line3  $cost_info"
  else
    line3="$cost_info"
  fi
fi

# Add API response time
if [ -n "$api_duration_ms" ] && [ "$api_duration_ms" != "null" ] && [ "$api_duration_ms" != "" ] && [ "$api_duration_ms" -gt 0 ] 2>/dev/null; then
  api_sec=$((api_duration_ms / 1000))
  api_min=$((api_sec / 60))
  api_remaining_sec=$((api_sec % 60))
  if [ "$api_min" -gt 0 ]; then
    api_time_fmt="${api_min}m ${api_remaining_sec}s"
  else
    api_time_fmt="${api_remaining_sec}s"
  fi
  api_info="üîå $(api_color)API: ${api_time_fmt}$(rst)"
  if [ -n "$line3" ]; then
    line3="$line3  $api_info"
  else
    line3="$api_info"
  fi
fi

# Add model ID
if [ -n "$model_id" ] && [ "$model_id" != "null" ] && [ "$model_id" != "" ]; then
  mid_info="üè∑Ô∏è $(model_id_color)${model_id}$(rst)"
  if [ -n "$line3" ]; then
    line3="$line3  $mid_info"
  else
    line3="$mid_info"
  fi
fi

# Add TODO progress if there are any tasks
if [ "$todo_total" -gt 0 ]; then
  todo_remaining=$((todo_pending + todo_inprogress))
  if [ "$todo_remaining" -gt 0 ]; then
    # Tasks remaining - show warning color
    todo_info="üìã $(todo_warning_color)TODOs: ${todo_complete}/${todo_total}"
    if [ "$todo_inprogress" -gt 0 ]; then
      todo_info="$todo_info (${todo_inprogress} active)"
    fi
    todo_info="$todo_info$(rst)"
  else
    # All complete - show green
    todo_info="üìã $(todo_color)TODOs: ‚úÖ ${todo_complete}/${todo_total}$(rst)"
  fi

  if [ -n "$line3" ]; then
    line3="$line3  $todo_info"
  else
    line3="$todo_info"
  fi
fi

# Line 4: Transcript path (OSC 8 clickable link)
line4=""
if [ -n "$transcript_path" ] && [ "$transcript_path" != "null" ] && [ "$transcript_path" != "" ]; then
  # Shorten path for display
  short_transcript=$(echo "$transcript_path" | sed "s|^$HOME|~|g")
  # OSC 8 hyperlink: \e]8;;URL\aTEXT\e]8;;\a
  line4="üìú $(link_color)\033]8;;file://${transcript_path}\a${short_transcript}\033]8;;\a$(rst)"
fi

# Print lines
if [ -n "$line2" ]; then
  printf '\n%s' "$line2"
fi
if [ -n "$line3" ]; then
  printf '\n%s' "$line3"
fi
if [ -n "$line4" ]; then
  printf '\n'"$line4"
fi
printf '\n'
